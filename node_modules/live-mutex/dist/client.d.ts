/// <reference types="node" />
import * as net from 'net';
export declare const log: {
    info: any;
    error: any;
};
export interface IClientOptions {
    key: string;
    listener: Function;
    host: string;
    port: number;
    unlockRequestTimeout: number;
    lockRequestTimeout: number;
    unlockRetryMax: number;
    lockRetryMax: number;
    ttl: number;
}
export declare type TClientOptions = Partial<IClientOptions>;
export interface IUuidTimeoutBool {
    [key: string]: boolean;
}
export declare type ErrFirstDataCallback = (err: any, val?: any) => void;
export interface IClientResolution {
    [key: string]: ErrFirstDataCallback;
}
export interface IBookkeepingHash {
    [key: string]: IBookkeeping;
}
export interface IBookkeeping {
    rawLockCount: number;
    rawUnlockCount: number;
    lockCount: number;
    unlockCount: number;
}
export declare type LMClientCallBack = (err: any, c?: Client) => void;
export declare type Ensure = (cb?: LMClientCallBack) => Promise<Client>;
export interface IUuidBooleanHash {
    [key: string]: boolean;
}
export interface LMClientLockOpts {
}
export interface LMClientUnlockOpts {
}
export interface ILockHolderCount {
    [key: string]: number;
}
export declare type LMLockSuccessData = {
    acquired: boolean;
    key: string;
    unlock?: LMClientUnlockConvenienceCallback;
    lockUuid: string;
    id: string;
};
export declare type LMClientLockCallBack = (err: any, val: LMLockSuccessData) => void;
export declare type LMClientUnlockCallBack = (err: any, uuid?: string) => void;
export declare type ErrorFirstCallBack = (err: any) => void;
export declare type LMClientUnlockConvenienceCallback = (fn: ErrorFirstCallBack) => void;
export declare class Client {
    port: number;
    host: string;
    listeners: Object;
    opts: TClientOptions;
    ttl: number;
    unlockTimeout: number;
    lockTimeout: number;
    lockRetryMax: number;
    unlockRetryMax: number;
    ws: net.Socket;
    timeouts: IUuidTimeoutBool;
    resolutions: IClientResolution;
    bookkeeping: IBookkeepingHash;
    ensure: Ensure;
    connect: Ensure;
    giveups: IUuidBooleanHash;
    write: Function;
    isOpen: boolean;
    close: Function;
    constructor(o: TClientOptions, cb?: LMClientCallBack);
    static create(opts: TClientOptions): Client;
    requestLockInfo(key: string, opts?: any, cb?: Function): void;
    lockp(key: string, opts?: Partial<LMClientLockOpts>): Promise<LMLockSuccessData>;
    unlockp(key: string, opts?: Partial<LMClientUnlockOpts>): Promise<{}>;
    acquire(key: string, opts?: Partial<LMClientLockOpts>): any;
    release(key: string, opts?: Partial<LMClientUnlockOpts>): any;
    acquireLock(key: string, opts?: Partial<LMClientLockOpts>): any;
    releaseLock(key: string, opts?: Partial<LMClientUnlockOpts>): any;
    promisifyUnlock(fn: Function): Promise<{}>;
    private cleanUp(to, uuid);
    private callbackWithError(err, uuid, cb, key, to);
    lock(key: string, opts: any, cb?: LMClientLockCallBack): void;
    noop(): void;
    unlock(key: string, opts?: any, cb?: LMClientUnlockCallBack): void;
}
export default Client;
export declare const LMClient: typeof Client;
export declare const LvMtxClient: typeof Client;
